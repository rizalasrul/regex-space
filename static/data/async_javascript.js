export default [
  {
    slug: 'pengenalan',
    label: 'Pengenalan',
    image_thumbnail: '01.webp',
    isUnlock: true,
    isActive: true,
    content: `<h1>Apa itu async javascript?<\/h1> <p>\r\n            Asynchronous javascript adalah salah satu bagian terpenting dari bahasa pemrograman javascript. Dengan memahami ini, kita dapat mengatur cara kita melakukan suatu perintah yang membutuhkan waktu ketika mengeksekusinya. Contoh perintah tersebut seperti request data dari database atau dari suatu API.\r\n          <\/p> <p>\r\n            Secara singkat, kode asynchronous adalah kode yang dapat dikerjakan saat itu juga, akan tetapi kita tidak tahu selesainya kapan.\r\n          <\/p> <p>\r\n            Sebelum kita membahas lebih lanjut mengenai kode asynchronous, mari kita memahami tentang synchronous.\r\n          <\/p> <h1>Synchronous javascript<\/h1> <p>\r\n            Secara alamiah, kode pada javascript dijalankan secara synchronous, yang mana berarti javascript hanya bisa mengeksekusi satu statement atau satu baris pada satu waktu, dari atas ke bawah.\r\n          <\/p> <p>\r\n            Seperti contoh pada kode di bawah.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'baris pertama\'<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'baris kedua\'<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'baris ketiga\'<\/span>);<\/code><\/pre> <p>\r\n            Dari kode di atas, kode pada baris pertama akan dieksekusi terlebih dahulu, setelah itu dilanjutkan ke baris kedua, ketiga, dan seterusnya. Kode pada baris ketiga tidak dapat dieksekusi dulu sebelum kode pada baris kedua selesai dieksekusi. Dari contoh tersebut, kode javascript akan dieksekusi berurutan dari atas ke bawah pada satu waktu.\r\n          <\/p> <h1>Single threaded<\/h1> <p>\r\n            Contoh kasus dari kode di atas dapat diartikan sebagai single threaded.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/01-1.webp\" alt=\"Proses single thread sederhana\"> <figcaption>Proses single thread sederhana<\/figcaption><\/figure> <p>\r\n            Thread itu seperti urutan pernyataan yang teratur dan satu pernyataan hanya dapat dikerjakan satu waktu hingga pernyataan tersebut selesai. Inti dari synchronous adalah satu pernyataan akan dieksekusi setelah pernyataan sebelumnya selesai tereksekusi.\r\n          <\/p> <p>\r\n            Lalu bayangkan kita memiliki skenario seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/01-2.webp\" alt=\"Proses single thread dengan request data\"> <figcaption>Proses single thread dengan request data<\/figcaption><\/figure> <p>\r\n            Pada Pernyataan 3, kita akan meminta data dari database melalui API. Karena database kita berada di jaringan atau server yang berbeda, ada kemungkinan kalau proses meminta data tersebut akan memakan waktu, bisa dua atau tiga detik, atau mungkin bisa lebih dari itu.\r\n          <\/p> <p>\r\n            Pada proses synchronous, karena satu pernyataan hanya bisa dikerjakan ketika pernyataan sebelumnya selesai, maka proses pada Pernyataan 3 akan menghentikan program. Kondisi itu biasa disebut sebagai <b>blocking code<\/b> karena Pernyataan 3 menghalangi proses pada Pernyataan 4. Proses pada Pernyataan 4 akan baru dijalankan jika Pernyataan 3 selesai, yang mana kita tidak tahu kapan Pernyataan 3 akan selesai tereksekusi.\r\n          <\/p> <p>\r\n            Mungkin kita berpikir bahwa tidak masalah jika program akan berhenti selama dua atau tiga detik. Bagaimana jika kita memiliki banyak fungsi yang serupa, seperti ini skenario ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/01-3.webp\" alt=\"Proses single thread dengan request data yang lebih banyak\"> <figcaption>Proses single thread dengan request data yang lebih banyak<\/figcaption><\/figure> <p>\r\n            Bagaimana jika proses yang ada pada Pernyataan 2 memakan waktu lebih banyak daripada Pernyataan 3? Sehingga dapat menghalangi proses pada pernyataan-pernyataan lain setelahnya. Proses seperti ini yang mengakibatkan proses synchronous memiliki efek negatif dan proses asynchronous hadir sebagai penyelamat.\r\n          <\/p> <h1>Async to the rescue<\/h1> <p>\r\n            Selalu ingat prinsip dari kode asynchronous.\r\n          <\/p> <blockquote><p>\r\n              Start something now and finish it later\r\n            <\/p><\/blockquote> <p>\r\n            Dari permasalah sebelumnya, kita dapat menggunakan solusi dari kode asynchronous seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/01-4.webp\" alt=\"Proses single thread dengan async proses\"> <figcaption>Proses single thread dengan async proses<\/figcaption><\/figure> <p>\r\n            Alih-alih kita menggunakan proses synchronous pada Pernyataan 2, kita akan menggunakan proses asynchronous, yang mana fungsi pada Pernyataan 2 dapat langsung dieksekusi, dan akan selesai ketika berhasil mengambil data dari database. Sembari Pernyataan 2 mengambil data dari database, program dapat melanjutkan mengeksekusi Pernyataan 3 dan Pernyataan 4 secara paralel. Ketika Pernyataan 2 telah berhasil mengambil data, akan ada fungsi callback yang akan tereksekusi.\r\n          <\/p> <p>\r\n            Lalu bagaimana proses asynchronous tersebut terjadi?\r\n          <\/p> <p>\r\n            Pertama, Pernyataan 1 akan dieksekusi sebagaimana proses synchronous terjadi. Setelah Pernyataan 1 selesai, program akan lanjut mengeksekusi Pernyataan 2. Karena Pernyataan 2 mengeksekusi proses untuk meminta data pada database, Pernyataan 2 akan menjalankan <em>asynchronous function<\/em> untuk meminta data tersebut. Hal itu berarti program menjalankan proses tersebut terpisah dari lingkup single thread.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/01-5.webp\" alt=\"Proses single thread dengan async function\"> <figcaption>Proses single thread dengan async function<\/figcaption><\/figure> <p>\r\n            Asynchronous function juga memiliki fungsi callback yang otomatis akan terpanggil ketika proses asynchronous tersebut selesai. Karena proses meminta data menggunakan asynchronous function dan berada di thread yang berbeda, maka program dapat melanjutkan mengeksekusi Pernyataan 3 dan Pernyataan 4 secara single thread. Meskipun begitu, proses asynchronous tersebut tetap berjalan.\r\n          <\/p> <p>\r\n            Inilah inti dari asynchronous programming, yaitu program dapat dieksekusi sekarang dan selesai kapan saja tanpa harus membuat program tersebut terhalangi.\r\n          <\/p> <h1>Implementasi pada kode<\/h1> <p>\r\n            Kita akan melakukan demo sederhana menggunakan kode javascript.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">1<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">2<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">3<\/span>);<\/code><\/pre> <p>\r\n            Kita sudah tahu bahwa secara alamiah, javascript mengeksekusi kode tersebut baris per baris. Log yang muncul akan angka 1, 2, 3, dan 4 seperti pada gambar di bawah.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/01-6.webp\" alt=\"Output pada console dari hasil percobaan\"> <figcaption>Output pada console dari hasil percobaan<\/figcaption><\/figure> <p>\r\n            Lalu di tengah-tengah, kita akan sisipi dengan fungsi javascript <code>setTimeout<\/code>. Fungsi <code>setTimeout<\/code> digunakan untuk menjalankan suatu pernyataan setelah sejumlah milidetik. Selengkapnya bisa simak tautan <a href=\"https:\/\/www.w3schools.com\/jsref\/met_win_settimeout.asp\" target=\"_blank\" rel=\"noopener\">ini<\/a>.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">1<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">2<\/span>);\r\n\r\n<span class=\"hljs-built_in\">setTimeout<\/span>(<span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Menjalankan fungsi callback\'<\/span>);\r\n}, <span class=\"hljs-number\">2000<\/span>);\r\n\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">3<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">4<\/span>);\r\n<\/code><\/pre> <p>\r\n            Jika ini adalah single thread, maka pernyataan <code>console.log(4)<\/code> akan dijalankan setelah fungsi <code>setTimeout<\/code> selesai dalam waktu 2000 milidetik atau dua detik. Tetapi fungsi <code>setTimeout<\/code> ini dapat berjalan secara asynchronous. Alih-alih menghalangi kode, justru fungsi tersebut akan berjalan beriringan dengan pernyataan <code>console.log<\/code> yang lain. Log dapat dilihat di bawah.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/01-7.webp\" alt=\"Output pada console dari hasil percobaan\"> <figcaption>Output pada console dari hasil percobaan<\/figcaption><\/figure> <p>\r\n            Terlihat bahwa meskipun pernyataan <code>setTimeout<\/code> berada di antara kode, output yang dihasilkan tetap berada di paling bawah. Hal itu karena <code>setTimeout<\/code> akan menunggu selama dua detik untuk dieksekusi.\r\n          <\/p> <h1>Tahap selanjutnya<\/h1> <p>\r\n            Kedepannya, kita akan mengganti pernyataan <code>setTimeout<\/code> tersebut dengan HTTP request. Secara konsep sama saja, karena proses HTTP request juga akan dilakukan secara asynchronous.\r\n          <\/p>`,
  },
  {
    slug: 'http-request',
    label: 'HTTP Request',
    image_thumbnail: '02.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Apa itu HTTP request?<\/h1> <p>\r\n            Pada tahap sebelumnya kita sudah memahami bagaimana kode asynchronous bekerja serta bagaimana cara menggunakan fungsi callback yang dieksekusi setelah kode asynchronous selesai. Kali ini kita akan membahas mengenai HTTP request, sebagai salah satu hal terpenting jika kita membahas mengenai proses asynchronous.\r\n          <\/p> <p>\r\n            Ada kalanya ketika kita mengembangkan sebuah website, kita perlu membuat fitur yang berhubungan dengan database. Seperti fitur menampilkan komentar, menyimpan data pelanggan, hingga menampilkan daftar postingan. Semua data tersebut bisa jadi disimpan di server lain atau di database kita sendiri. Untuk berkomunikasi dengan server lain ataupun database kita sendiri, kita memerlukan HTTP request untuk menjangkaunya dan mendapatkan datanya. Ketika kita membuat HTTP request, kita akan menggunakan <b>API endpoint<\/b>. Melalui API endpoint inilah kita berkomunikasi dengan database kita maupun server yang ada di luar aplikasi kita.\r\n          <\/p> <p>\r\n            Sebagai contoh bayangkan kita memiliki data seluruh lagu yang ada di dunia. Data tersebut kita taruh di sebuah server. Lalu kita sebagai penyedia server membuat sebuah endpoint <code>https:\/\/api.music.com\/song<\/code>. Sehingga jika ada situs lain yang ingin mengakses data lagu dari server kita, mereka tinggal melakukan HTTP request melalui endpoint yang sudah kita berikan.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/02-1.webp\" alt=\"Skema sederhana dari website ke server\"> <figcaption>Skema sederhana dari website ke server<\/figcaption><\/figure> <p>\r\n            Dari sudut pandang pemilik website yang ingin melakukan HTTP request, mereka akan melakukan HTTP request melalui endpoint <code>https:\/\/api.music.com\/song<\/code>. Lalu server akan menerima request dari website, dan server akan memberikan data lagu sebagai response. Lalu website tersebut akan menerima data lagu dan dapat mengolahnya.\r\n          <\/p> <p>\r\n            Dari simulasi di atas kita dapat menangkap bahwa HTTP request selalu membutuhkan API endpoint sebagai yang menjembatani antara website dengan server eksternal yang datanya mau kita minta. Lalu server yang menerima request akan memberikan data kepada website berupa response. Secara umum responses akan diberikan dengan format JSON (Javascript Object Notation). Selengkapnya kita dapat mendalami mengenai JSON di <a href=\"https:\/\/www.json.org\/json-en.html\" target=\"_blank\" rel=\"noopener\">sini<\/a>.\r\n          <\/p> <h1>HTTP request pada javascript<\/h1> <p>\r\n            Pada eksperimen kali ini kita akan menggunakan bantuan <a href=\"https:\/\/jsonplaceholder.typicode.com\/\" target=\"_blank\" rel=\"noopener\">JSON Placeholder<\/a> untuk membuat fake endpoint. Sehingga kita bisa lebih fokus dalam memahami HTTP request alih-alih terpaku pada pembuatan endpoint.\r\n          <\/p> <p>\r\n            Endpoint yang kita pakai adalah <code>https:\/\/jsonplaceholder.typicode.com\/todos<\/code>. Kode pada javascript akan menjadi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\nrequest.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\n\r\nrequest.send();\r\n<\/code><\/pre> <p>\r\n            Javascript memiliki built-in code untuk melakukan HTTP request, yaitu menggunakan class <code>XMLHttpRequest<\/code>. Perintah <code>request.open<\/code> akan membuka koneksi ke endpoint yang ingin kita tuju. Perintah tersebut memiliki dua parameter, yaitu \"GET\" dan API endpoint. Parameter pertama digunakan untuk metode pemanggilan, dalam hal ini berarti metode get. Sedangkan parameter kedua adalah API endpoint yang ingin kita tembak untuk mendapatkan response.\r\n          <\/p> <p>\r\n            Tetapi perintah <code>request.open<\/code> hanya digunakan untuk membuka koneksi, belum melakukan HTTP request. Untuk melakukannya, diperlukan perintah <code>request.send<\/code> seperti yang ada di baris terakhir.\r\n          <\/p> <p>\r\n            Jika berhasil, kita bisa melihat di bagian console browser kita, lalu pilih tab \"Headers\". Kita dapat melihat request kita dengan status code 200, yang mana berarti request kita berhasil.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/02-2.webp\" alt=\"Output yang dihasilkan dari HTTP request\"> <figcaption>Output yang dihasilkan dari HTTP request<\/figcaption><\/figure> <p>\r\n            Lalu jika kita membuka tab \"Preview\", kita bisa melihat data response yang diberikan oleh server. Kita dapat mengolah data tersebut sesuai keinginan kita.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/02-3.webp\" alt=\"Response data dari HTTP request\"> <figcaption>Response data dari HTTP request<\/figcaption><\/figure> <p>\r\n            Untuk mengambil response, kita perlu tahu apakah request yang kita lakukan sudah selesai atau belum. Kita dapat melacak progres dari request kita menggunakan event listener dan spesifik event yang bernama <code>readystatechange<\/code>. Kodenya akan menjadi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\nrequest.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(request, request.readyState);\r\n});\r\n\r\nrequest.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\nrequest.send();\r\n<\/code><\/pre> <p>\r\n            Dari kode di atas kita menambahkan kemampuan pada event <code>readystatechange<\/code> untuk menampilkan log ketika kondisi event kita berubah. Lalu kita juga menampilkan log dari <code>readyState<\/code> yang berupa kode. Hasil pada log akan seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/02-4.webp\" alt=\"Log dari readyState\"> <figcaption>Log dari readyState<\/figcaption><\/figure> <p>\r\n            Terlihat bahwa akan muncul request beserta kode dari kondisi event tersebut berupa angka 1, 2, 3, dan 4. Untuk memahami angka-angka ini, kita bisa merujuk dari halaman ini. Kurang lebih seperti ini.\r\n          <\/p> <ul><li>Kode 0 berarti client (website) baru saja terbuat. Fungsi <code>open()<\/code> belum dijalankan<\/li> <li>Kode 1 berarti fungsi <code>open()<\/code> baru saja dijalankan.<\/li> <li>Kode 2 berarti fungsi <code>send()<\/code> baru saja dijalankan.<\/li> <li>Kode 3 berarti sedang proses mengunduh data dari server.<\/li> <li>Kode 4 berarti client telah menerima data dari server. Proses selesai.<\/li><\/ul> <p>\r\n            Dari informasi di atas, kita bisa mengambil response ketika kode sudah bernilai 4. Berikut adalah request ketika kode bernilai 4.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/02-5.webp\" alt=\"Rincian log dari kode 4\"> <figcaption>Rincian log dari kode 4<\/figcaption><\/figure> <p>\r\n            Data response disimpan di properti <code>responseText<\/code>. Kita bisa mengambil data response melalui properti tersebut.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\nrequest.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(request.responseText);\r\n  }\r\n});\r\n\r\nrequest.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\nrequest.send();\r\n<\/code><\/pre> <p>\r\n            Berikut adalah log pada browser.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/02-6.webp\" alt=\"Hasil response data dari request\"> <figcaption>Hasil response data dari request<\/figcaption><\/figure> <p>\r\n            Jika kita lihat, sekilas data yang ditampilkan di log adalah JSON. Padahal sebenarnya itu bukan JSON, melainkan string besar yang menyerupai JSON. Untuk mengolahnya, kita perlu melakukan parsing dari string ke JSON.\r\n          <\/p> <h1>Tahap selanjutnya<\/h1> <p>\r\n            Setelah ini kita akan membahas lebih dalam mengenai response status supaya kita lebih memahami kondisi apa saja yang bisa terjadi ketika kita melakukan HTTP request.\r\n          <\/p>`,
  },
  {
    slug: 'status-codes',
    label: 'Status Codes',
    image_thumbnail: '03.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Menangani error ketika request gagal<\/h1> <p>\r\n            Di tahap sebelumnya kita memiliki kode seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\nrequest.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(request.responseText);\r\n  }\r\n});\r\n\r\nrequest.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\nrequest.send();\r\n<\/code><\/pre> <p>\r\n            Bisa dilihat bahwa kita hanya menampilkan <code>responseText<\/code> ketika proses HTTP request selesai, yang digambarkan dengan <code>readyState<\/code> bernilai 4.\r\n          <\/p> <p>\r\n            Bagaimana jika ternyata API endpoint yang kita akses itu tidak valid, seperti pada kode di bawah.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\nrequest.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(request.responseText);\r\n  }\r\n});\r\n\r\nrequest.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todossss\'<\/span>);\r\nrequest.send();\r\n<\/code><\/pre> <p>\r\n            Pada console browser akan muncul seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/03-1.webp\" alt=\"Error pada console\"> <figcaption>Error pada console<\/figcaption><\/figure> <p>\r\n            Terlihat bahwa error muncul pada console. Jika kita klik error tersebut untuk melihat lebih jelas, maka akan seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/03-2.webp\" alt=\"Error pada console\"> <figcaption>Error pada console<\/figcaption><\/figure> <p>\r\n            Terlihat pula kalau ternyata request yang kita lakukan tadi memiliki status code bernilai 404 dengan warna merah, yang menandakan kalau request kita memang error. Dari gambar sebelumnya juga terlihat bahwa ketika error, maka kita tidak menerima response apapun. Oleh karena itu solusinya adalah kita hanya menampilkan response ketika status code kita 200 yang menandakan request kita berhasil dengan baik.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\nrequest.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(request.responseText);\r\n  }\r\n});\r\n\r\nrequest.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todossss\'<\/span>);\r\nrequest.send();\r\n<\/code><\/pre> <p>\r\n            Berikut adalah hasil di console.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/03-3.webp\" alt=\"Error pada console\"> <figcaption>Error pada console<\/figcaption><\/figure> <p>\r\n            Terlihat kalau kita sudah tidak menampilkan response, berbeda dengan sebelumnya terdapat response \"{}\" meskipun request kita error.\r\n          <\/p> <p>\r\n            Untuk lebih jelas mengenai status code, kita bisa merujuk ke tautan <a href=\"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Status\" target=\"_blank\" rel=\"noopener\">ini<\/a>. Jika bisa disimpulkan, status code tersebut seperti ini.\r\n          <\/p> <ul><li>Kode 1xx sebagai response informasi.<\/li> <li>Kode 2xx sebagai response berhasil.<\/li> <li>Kode 3xx sebagai redirect.<\/li> <li>Kode 4xx jika error terjadi di sisi client.<\/li> <li>Kode 5xx jika error terjadi di sisi server.<\/li><\/ul> <p>\r\n            Supaya lebih informatif, kita dapat menampilkan pesan error jika request kita bermasalah, seperti kode di bawah ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\nrequest.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(request.responseText);\r\n  } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(\u2018Terjadi error ketika request\u2019);\r\n  }\r\n});\r\n\r\nrequest.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todossss\'<\/span>);\r\nrequest.send();\r\n<\/code><\/pre> <p>\r\n            Lalu pada console akan seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/03-4.webp\" alt=\"Error pada console\"> <figcaption>Error pada console<\/figcaption><\/figure> <h1>Tahap selanjutnya<\/h1> <p>\r\n            Pada tahap selanjutnya kita akan menulis fungsi callback yang akan tereksekusi ketika proses asynchronous selesai, dalam hal ini ketika HTTP request selesai.\r\n          <\/p>`,
  },
  {
    slug: 'callback-function',
    label: 'Callback Function',
    image_thumbnail: '04.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Apa itu callback function?<\/h1> <p>\r\n            Fungsi callback adalah sebuah fungsi yang akan dijalankan ketika sebuah proses asynchronous selesai tereksekusi. Pada tahap ini kita akan mencoba mengimplementasikan fungsi callback pada kode yang sudah kita buat sebelumnya.\r\n          <\/p> <p>\r\n            Untuk itu, kita perlu melakukan penyesuaian terhadap kode kita menjadi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      <span class=\"hljs-built_in\">console<\/span>.log(request.responseText);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Terjadi error ketika request\'<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todossss\'<\/span>);\r\n  request.send();\r\n};\r\n\r\ngetTodo();<\/code><\/pre> <p>\r\n            Kita bungkus kode kita ke dalam sebuah fungsi <code>getTodo<\/code>. Sehingga jika kita ingin menjalankan kode tersebut, kita tinggal memanggil fungsi yang membungkusnya. Saya menggunakan <a href=\"https:\/\/www.w3schools.com\/js\/js_arrow_function.asp\" target=\"_blank\" rel=\"noopener\">arrow function<\/a>. Jika teman-teman lebih nyaman menggunakan fungsi biasa, tidak masalah.\r\n          <\/p> <p>\r\n            Kita akan membuat fungsi callback sebagai parameter dari fungsi <code>getTodo<\/code> tersebut. Lalu fungsi callback akan menggantikan perintah <code>console.log<\/code> yang ada di kode sebelumnya.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      callback();\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback();\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todossss\'<\/span>);\r\n  request.send();\r\n};\r\n\r\ngetTodo(<span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n});<\/code><\/pre> <p>\r\n            Tampilan pada console browser akan menjadi seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/04-1.webp\" alt=\"Fungsi callback berjalan\"> <figcaption>Fungsi callback berjalan<\/figcaption><\/figure> <p>\r\n            Terlihat bahwa fungsi callback sudah berjalan dengan baik. Tetapi masih ada masalah dari implementasi fungsi callback kita. Yaitu antara request kita error atau berhasil, fungsi callback sama-sama dijalankan. Kita ingin memberikan pembeda antara fungsi callback yang dijalankan ketika error dan fungsi callback yang dijalankan ketika berhasil.\r\n          <\/p> <p>\r\n            Untuk itu, kita bisa memberikan parameter ke dalam fungsi callback kita sebagai penanda. Seperti ini kode nya.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, request.responseText);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todossss\'<\/span>);\r\n  request.send();\r\n};\r\n\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n  <span class=\"hljs-built_in\">console<\/span>.log(err, data);\r\n});<\/code><\/pre> <p>\r\n            Tampilan pada console browser seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/04-2.webp\" alt=\"Fungsi callback berjalan ketika error\"> <figcaption>Fungsi callback berjalan ketika error<\/figcaption><\/figure> <p>\r\n            Lalu begini tampilan pada console ketika request kita berhasil.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/04-3.webp\" alt=\"Fungsi callback berjalan ketika berhasil\"> <figcaption>Fungsi callback berjalan ketika berhasil<\/figcaption><\/figure> <p>\r\n            Kita modifikasi sedikit di bagian fungsi callbacknya supaya hasil dari log menjadi lebih sesuai.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, request.responseText);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todoss\'<\/span>);\r\n  request.send();\r\n};\r\n\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n  <span class=\"hljs-keyword\">if<\/span> (err) <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});<\/code><\/pre> <p>\r\n            Berikut tampilan console ketika request gagal.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/04-4.webp\" alt=\"Fungsi callback berjalan ketika gagal\"> <figcaption>Fungsi callback berjalan ketika gagal<\/figcaption><\/figure> <p>\r\n            Berikut tampilan console ketika request berhasil.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/04-5.webp\" alt=\"Fungsi callback berjalan ketika berhasil\"> <figcaption>Fungsi callback berjalan ketika berhasil<\/figcaption><\/figure> <p>\r\n            Salah satu manfaat kita menaruh proses asynchronous ke dalam fungsi adalah supaya kita dapat mengatur fungsionalitas dari fungsi callback. Sehingga fungsi callback menjadi lebih fleksibel. Mari kita perhatikan contoh di bawah ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, request.responseText);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\n  request.send();\r\n};\r\n\r\n<span class=\"hljs-comment\">\/\/ Implementasi pertama<\/span>\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n  <span class=\"hljs-keyword\">if<\/span> (err) <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});\r\n\r\n<span class=\"hljs-comment\">\/\/ Berbeda dengan implementasi kedua<\/span>\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">if<\/span> (err) <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'ini error\'<\/span>);\r\n  <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'ini berhasil\'<\/span>);\r\n});<\/code><\/pre> <p>\r\n            Fungsi <code>getTodo<\/code> yang pertama memiliki fungsi callback yang fungsionalitasnya berbeda dengan <code>getTodo<\/code> yang kedua.\r\n          <\/p> <p>\r\n            Sekarang mari kita buktikan bahwa fungsi <code>getTodo<\/code> tidak menghalangi kode yang sifatnya single thread dengan kode di bawah ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, request.responseText);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\n  request.send();\r\n};\r\n\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">1<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">2<\/span>);\r\n\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n  <span class=\"hljs-keyword\">if<\/span> (err) <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});\r\n\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">3<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">4<\/span>);<\/code><\/pre> <p>\r\n            Berikut hasil pada console.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/04-6.webp\" alt=\"Fungsi callback berjalan secara asynchronous\"> <figcaption>Fungsi callback berjalan secara asynchronous<\/figcaption><\/figure> <p>\r\n            Terlihat bahwa console mencetak 1, 2, 3, dan 4 sampai selesai, barulah dia menampilkan fungsi callback dari <code>getTodo<\/code>.\r\n          <\/p> <h1>Tahap selanjutnya<\/h1> <p>\r\n            Pada tahap selanjutnya kita akan membahas mengenai penggunaan pada data dengan format JSON.\r\n          <\/p>`,
  },
  {
    slug: 'penggunaan-data-json',
    label :'Penggunaan Data JSON',
    image_thumbnail: '05.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Mengapa harus memahami JSON?<\/h1> <p>\r\n            Semoga pada tahap sebelumnya kita memahami dasar-dasar dari cara membuat HTTP request. Sekarang kita akan membahas JSON, yang mana dia adalah format data yang hampir sebagian besar API mengembalikan data JSON pada data response.\r\n          <\/p> <p>\r\n            Jika pada tahap sebelumnya kita melihat response data seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/05-1.webp\" alt=\"String dengan format JSON\"> <figcaption>String dengan format JSON<\/figcaption><\/figure> <p>\r\n            Itu adalah data dengan format JSON. Hanya saja data tersebut bukanlah JSON, melainkan hanya data bertipe string yang memiliki format JSON. Yang akan kita lakukan adalah mengolah string tersebut menjadi data yang benar-benar berformat JSON.\r\n          <\/p> <p>\r\n            Untuk mengubah string menjadi JSON, kita dapat menggunakan fungsi <code>JSON.parse()<\/code> yang sudah bawaan dari javascript.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-built_in\">JSON<\/span>.parse(request.responseText);\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, data);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\n  request.send();\r\n};\r\n\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n  <span class=\"hljs-keyword\">if<\/span> (err) <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});<\/code><\/pre> <p>\r\n            Berikut adalah tampilan pada console.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/05-2.webp\" alt=\"Data dengan format JSON\"> <figcaption>Data dengan format JSON<\/figcaption><\/figure> <p>\r\n            Kita bisa lihat pada console bahwa yang muncul adalah array dengan ukuran 100 elemen. Array tersebut memuat objek yang berisikan beberapa attribute seperti <code>id<\/code>, <code>userId<\/code>, <code>title<\/code>, dan <code>completed<\/code>. Kita bisa melakukan perulangan untuk menampilkan masing-masing elemen dari array tersebut.\r\n          <\/p> <h1>Tahap selanjutnya<\/h1> <p>\r\n            Pada tahap selanjutnya kita akan belajar mengenai bagaimana menangani jika terdapat dua request dengan response yang salin berkaitan.\r\n          <\/p>`,
  },
  {
    slug: 'callback-hell',
    label: 'Callback Hell',
    image_thumbnail: '06.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Menangani lebih dari satu request<\/h1> <p>\r\n            Kita akan mencoba untuk menjalankan beberapa request yang saling berkaitan. Jadi kita akan menjalankan request pertama, jika request pertama selesai kita akan menjalankan request kedua, jika request kedua selesai kita akan menjalankan request ketiga. Begitu seterusnya hingga seluruh API endpoint kita berhasil mendapatkan response.\r\n          <\/p> <p>\r\n            Untuk itu, kita masih menggunakan API endpoint dari JSON Placeholder. Kita akan menggunakan endpoint:\r\n          <\/p> <ul><li><code>https:\/\/jsonplaceholder.typicode.com\/todos<\/code><\/li> <li><code>https:\/\/jsonplaceholder.typicode.com\/users<\/code><\/li> <li><code>https:\/\/jsonplaceholder.typicode.com\/posts<\/code><\/li><\/ul> <p>\r\n            Proses saling menunggu hingga request selesai ini adalah konsep yang umum terjadi ketika kita mengembangkan aplikasi yang membutuhkan API endpoint yang berbeda. Bahkan kita akan menemui kondisi dimana request kedua membutuhkan parameter yang didapat dari response pada request pertama. Jadi bagaimana caranya kita membuat beberapa request, dan mengetahui bahwa request sebelumnya sudah selesai sehingga kita bisa menjalankan request selanjutnya?\r\n          <\/p> <p>\r\n            Mari kita lihat kode yang sudah kita tulis sebelumnya.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-built_in\">JSON<\/span>.parse(request.responseText);\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, data);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>);\r\n  request.send();\r\n};\r\n\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n  <span class=\"hljs-keyword\">if<\/span> (err) <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});<\/code><\/pre> <p>\r\n            Dari kode di atas kita bisa tahu bahwa request akan selesai ketika masuk ke dalam blok kode <code>if (err) console.log(err);<\/code> untuk kondisi error, dan ke dalam blok kode <code>else console.log(data);<\/code> untuk kondisi berhasil. Kita bisa memanfaatkan blok kode itu.\r\n          <\/p> <p>\r\n            Lalu juga perlu adanya parameter yang menampil API endpoint yang kita panggil. Sedangkan pada kode di atas, API yang dipakai masih ditulis tanpa variabel, sehingga tidak fleksibel. Maka kita perlu mengubahnya menjadi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">resource, callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-built_in\">JSON<\/span>.parse(request.responseText);\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, data);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, resource);\r\n  request.send();\r\n};\r\n\r\ngetTodo(<span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Fungsi callback dijalankan\'<\/span>);\r\n  <span class=\"hljs-keyword\">if<\/span> (err) <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});<\/code><\/pre> <p>\r\n            Parameter <code>resource<\/code> akan dilewatkan ketika memanggil fungsi <code>getTodo<\/code>. Variabel <code>resource<\/code> akan berisi API endpoint yang mau kita tuju.\r\n          <\/p> <p>\r\n            Lalu kita akan mencoba untuk memanggil ketiga API endpoint yang kita dapat dari JSON Placeholder pada kode kita. Pada tahap ini kita asumsikan bahwa request yang kita panggil akan selalu berhasil, sehingga kita tidak memerlukan pengecekan error.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">resource, callback<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n  request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n      <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-built_in\">JSON<\/span>.parse(request.responseText);\r\n      callback(<span class=\"hljs-literal\">undefined<\/span>, data);\r\n    } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n      callback(<span class=\"hljs-string\">\'HTTP request error\'<\/span>, <span class=\"hljs-literal\">undefined<\/span>);\r\n    }\r\n  });\r\n\r\n  request.open(<span class=\"hljs-string\">\'GET\'<\/span>, resource);\r\n  request.send();\r\n};\r\n\r\n<span class=\"hljs-keyword\">const<\/span> endpointOne = <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>;\r\n<span class=\"hljs-keyword\">const<\/span> endpointTwo = <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/users\'<\/span>;\r\n<span class=\"hljs-keyword\">const<\/span> endpointThree = <span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/posts\'<\/span>;\r\ngetTodo(endpointOne, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  getTodo(endpointTwo, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n    getTodo(endpointThree, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n      <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n    });\r\n  });\r\n});<\/code><\/pre> <p>\r\n            Berikut hasil dari beberapa request yang kita lakukan.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/06-1.webp\" alt=\"Hasil dari beberapa HTTP request\"> <figcaption>Hasil dari beberapa HTTP request<\/figcaption><\/figure> <p>\r\n            Dapat dilihat bahwa response yang dihasilkan berurutan sesuai dengan request yang kita lakukan.\r\n          <\/p> <h1>Apa itu callback hell?<\/h1> <p>\r\n            Mari kita lihat potongan dari kode yang sudah kita tulis\r\n          <\/p> <pre><code class=\"javascript hljs\">... \r\n...\r\n...\r\ngetTodo(endpointOne, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  getTodo(endpointTwo, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n    getTodo(endpointThree, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data<\/span>) =&gt;<\/span> {\r\n      <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n    });\r\n  });\r\n});<\/code><\/pre> <p>\r\n            Terlihat bahwa indentasi yang dihasilkan dari request berkali-kali semakin ke dalam. Hal itu cukup membuat kode kita menjadi tidak rapi. Bayangkan jika kita punya puluhan request yang serupa. Maka kode yang kita buat akan menjadi jelek karena indentasi yang semakin ke dalam.\r\n          <\/p> <p>\r\n            Itulah yang dinamakan dengan callback hell, atau callback yang bersarang. Semakin dalam, semakin tidak baik. Callback hell akan menjadi sesuatu yang sangat sulit dirawat.\r\n          <\/p> <p>\r\n            Untuk menghindari adanya callback hell, kita akan menggunakan <b>promise<\/b>. Kita akan bahas ini di tahap selanjutnya.\r\n          <\/p>`,
  },
  {
    slug: 'promises',
    label: 'Promises',
    image_thumbnail: '07.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Apa itu promise?<\/h1> <p>\r\n            Untuk melakukan HTTP request, javascript memiliki fungsi alami bernama promise. Fungsi ini dapat memecahkan permasalahan berkaitan dengan callback hell, karena kode yang dihasilkan menjadi lebih rapi.\r\n          <\/p> <p>\r\n            Untuk menjelaskan konsep dari promise, mari kita lihat kode yang ada di bawah.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getSomething = <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">return<\/span> <span class=\"hljs-keyword\">new<\/span> <span class=\"hljs-built_in\">Promise<\/span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-comment\">\/\/ melakukan HTTP request<\/span>\r\n    resolve(<span class=\"hljs-string\">\'data response\'<\/span>); <span class=\"hljs-comment\">\/\/ jika berhasil<\/span>\r\n    reject(<span class=\"hljs-string\">\'pesan error\'<\/span>); <span class=\"hljs-comment\">\/\/jika gagal<\/span>\r\n  });\r\n};<\/code><\/pre> <p>\r\n            Untuk membuat promise, kita memerlukan instance promise dengan keyword <code>new Promise()<\/code>. Objek promise memiliki parameter berupa fungsi dengan parameter <code>resolve<\/code> dan <code>reject<\/code>. Variabel <code>resolve<\/code> dipanggil sebagai penanda kalau request kita berhasil, sedangkan variabel <code>reject<\/code> dipanggil sebagai penanda kalau request kita gagal.\r\n          <\/p> <p>\r\n            Untuk memanggil fungsi <code>getSomething<\/code> yang memiliki balikan berupa promise, kita bisa menggunakan penulisan seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\">getSomething()\r\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">data<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data); <span class=\"hljs-comment\">\/\/ akan dieksekusi ketika berhasil<\/span>\r\n  })\r\n  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  });<\/code><\/pre> <p>\r\n            Fungsi <code>getSomething<\/code> akan dijalankan dengan keyword <code>.then()<\/code> dan <code>.catch()<\/code>. Fungsi yang ada di dalam <code>.then()<\/code> akan dieksekusi ketika fungsi <code>resolve<\/code> pada promise juga dijalankan, yang mana berarti request kita berhasil. Fungsi yang ada di dalam <code>.catch()<\/code> akan dieksekusi ketika fungsi <code>reject<\/code> pada promise dijalankan juga, yang mana berarti request kita gagal.\r\n          <\/p> <p>\r\n            Kita coba menggunakan kode ini untuk melihat hasilnya di console.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getSomething = <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">return<\/span> <span class=\"hljs-keyword\">new<\/span> <span class=\"hljs-built_in\">Promise<\/span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject<\/span>) =&gt;<\/span> {\r\n    resolve(<span class=\"hljs-string\">\'data response\'<\/span>);\r\n  });\r\n};\r\n\r\ngetSomething()\r\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">data<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  })\r\n  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  });<\/code><\/pre> <p>\r\n            Berikut hasilnya.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/07-1.webp\" alt=\"Hasil dari HTTP request menggunakan promise\"> <figcaption>Hasil dari HTTP request menggunakan promise<\/figcaption><\/figure> <p>\r\n            Dan jika kita menggunakan seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getSomething = <span class=\"hljs-function\">() =&gt;<\/span> {\r\n  <span class=\"hljs-keyword\">return<\/span> <span class=\"hljs-keyword\">new<\/span> <span class=\"hljs-built_in\">Promise<\/span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject<\/span>) =&gt;<\/span> {\r\n    reject(<span class=\"hljs-string\">\'pesan error\'<\/span>);\r\n  });\r\n};\r\n\r\ngetSomething()\r\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">data<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  })\r\n  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(err);\r\n  });<\/code><\/pre> <p>\r\n            Maka seperti ini hasilnya.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/07-2.webp\" alt=\"Hasil dari HTTP request menggunakan promise\"> <figcaption>Hasil dari HTTP request menggunakan promise<\/figcaption><\/figure> <h1>Implementasi dengan kode sebelumya<\/h1> <p>\r\n            Itu tadi adalah dasar-dasar dari promise yang perlu kita ketahui. Sekarang kita akan mengimplementasikan apa yang sudah kita pelajari terkait promise ini ke dalam kode yang sudah kita tulis sebelumnya.\r\n          <\/p> <p>\r\n            Kita akan memodifikasi kode yang ada di dalam fungsi <code>getTodo<\/code> sehingga balikan dari fungsi itu dapat berupa promise.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-function\">(<span class=\"hljs-params\">resource,<\/span>) =&gt;<\/span> {\r\n\r\n  <span class=\"hljs-keyword\">return<\/span> <span class=\"hljs-keyword\">new<\/span> <span class=\"hljs-built_in\">Promise<\/span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-keyword\">const<\/span> request = <span class=\"hljs-keyword\">new<\/span> XMLHttpRequest();\r\n\r\n    request.addEventListener(<span class=\"hljs-string\">\'readystatechange\'<\/span>, <span class=\"hljs-function\">() =&gt;<\/span> {\r\n      <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span> &amp;&amp; request.status === <span class=\"hljs-number\">200<\/span>) {\r\n        <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-built_in\">JSON<\/span>.parse(request.responseText);\r\n        resolve(data);\r\n      } <span class=\"hljs-keyword\">else<\/span> <span class=\"hljs-keyword\">if<\/span> (request.readyState === <span class=\"hljs-number\">4<\/span>) {\r\n        resolve(<span class=\"hljs-string\">\'HTTP request error\'<\/span>);\r\n      }\r\n    });\r\n\r\n    request.open(<span class=\"hljs-string\">\'GET\'<\/span>, resource);\r\n    request.send();\r\n  });\r\n};<\/code><\/pre> <p>\r\n            Secara garis besar, kita mengganti parameter <code>callback<\/code> menggunakan <code>resolve<\/code> dan <code>reject<\/code> yang sudah disediakan oleh promise.\r\n          <\/p> <p>\r\n            Untuk kode ketika pemanggilan fungsi <code>getTodo<\/code>, akan menjadi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\">getTodo(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>)\r\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">data<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Promise sukses: \'<\/span>, data);\r\n  })\r\n  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Promise gagal: \'<\/span>, err);\r\n  });<\/code><\/pre> <h1>Tahap selanjutnya<\/h1> <p>\r\n            Kita sudah memahami terkait promise dan bagaimana melakukan HTTP request menggunakan promise. Sebelumnya juga kita sempat menyinggung mengenai HTTP request yang berkali-kali dengan beberapa API endpoint yang berbeda-beda. Selanjutnya kita akan membahas mengenai pemanggilan API endpoint yang berkali-kali menggunakan promise supaya bisa menghindari callback hell. Pemanggilan API endpoint berkali-kali ini bisa kita sebut dengan istliah chaining promise.\r\n          <\/p>`,
  },
  {
    slug: 'chaining-promise',
    label: 'Chaining Promise',
    image_thumbnail: '08.webp',
    isUnlock: true,
    isActive: false,
    content: `<p>\r\n            Salah satu hal terbaik dari promise adalah kita bisa mengikatnya satu sama lain. Hal itu menjadikan kode yang kita tulis menjadi lebih rapi. Kita akan mencoba mengimplementasikan chaining promise ke dalam kode yang sebelumnya sudah kita tulis.\r\n          <\/p> <p>\r\n            Jika sebelumnya kode yang kita tulis seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\">... \r\n...\r\n...\r\ngetTodo(endpointOne, <span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err, data<\/span><\/span><\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span><\/span> {\r\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span><\/span>.log(data);\r\n  getTodo(endpointTwo, <span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err, data<\/span><\/span><\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span><\/span> {\r\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span><\/span>.log(data);\r\n    getTodo(endpointThree, <span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err, data<\/span><\/span><\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span><\/span> {\r\n      <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span><\/span>.log(data);\r\n    });\r\n  });\r\n});<\/code><\/pre> <p>\r\n            Maka akan menjadi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\">...\r\n...\r\n...\r\ngetTodo(endpointOne)\r\n  .then(<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span><\/span><\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span><\/span> {\r\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Promise 1 sukses: \'<\/span><\/span><\/span><\/span>, data);\r\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return<\/span><\/span><\/span><\/span> getTodo(endpointTwo);\r\n  })\r\n  .then(<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span><\/span><\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span><\/span> {\r\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Promise 2 sukses: \'<\/span><\/span><\/span><\/span>, data);\r\n    <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return<\/span><\/span><\/span><\/span> getTodo(endpointThree);\r\n  })\r\n  .then(<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span><\/span><\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span><\/span> {\r\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Promise 3 sukses: \'<\/span><\/span><\/span><\/span>, data);\r\n  })\r\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err<\/span><\/span><\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span><\/span> {\r\n    <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Promise gagal: \'<\/span><\/span><\/span><\/span>, err);\r\n  });\r\n<\/code><\/pre> <p>\r\n            Dilihat sekilas pun kode kita menjadi lebih rapi dibandingkan dengan sebelumnya.\r\n          <\/p> <p>\r\n            Jika dilihat terdapat tiga <code>.then()<\/code> dan satu <code>.catch()<\/code>. Kita bisa memahami mengapa terdapat tiga <code>.then()<\/code>, karena terdapat tiga kali HTTP request. Tetapi kita cukup memerlukan sekali <code>.catch()<\/code> untuk menangkap error dari masing-masing promise yang gagal.\r\n          <\/p> <p>\r\n            Kita akan mencoba menggagalkan request yang kedua untuk melihat <code>.catch()<\/code> bekerja.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/08-1.webp\" alt=\"Hasil dari menggagalkan request\"> <figcaption>Hasil dari menggagalkan request<\/figcaption><\/figure> <h1>Tahap selanjutnya<\/h1> <p>\r\n            Sebelumnya hingga saat ini kita menggunakan fungsi alami <code>XMLHttpRequest<\/code> untuk HTTP request. Kita akan belajar menggunakan fungsi alami lain dari javascript, yaitu <code>fetch<\/code> untuk HTTP request di tahap selanjutnya.\r\n          <\/p>`,
  },
  {
    slug: 'fetch-api',
    label: 'Fetch API',
    image_thumbnail: '09.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Apa itu fetch API?<\/h1> <p>\r\n          Fetch API adalah fungsi alami terbaru dari javascript yang dapat kita gunakan untuk HTTP request. Selengkapnya mengenai ini bisa kita akses di tautan <a href=\"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/Fetch_API\" target=\"_blank\" rel=\"noopener\">ini<\/a>.\r\n        <\/p> <p>\r\n          Fetch API sangat bagus untuk digunakan. Salah satu alasannya adalah karena fetch sudah mengimplementasi promise secara otomatis. Selain itu juga menggunakan fetch dapat mempersingkat kita dalam menulis kode.\r\n        <\/p> <p>\r\n          Tetapi tidak ada salahnya kita memahami <code>XMLHttpRequest<\/code>, karena hal itu dapat memperkuat pemahaman kita terkait javascript asynchronous.\r\n        <\/p> <h1>Penulisan kode menggunakan fetch<\/h1> <p>\r\n          Berikut adalah contoh kode jika kita melakukan HTTP request menggunakan <code>fetch<\/code>.\r\n        <\/p> <pre><code class=\"javascript hljs\">fetch(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span><\/span><\/span>)\r\n.then(<span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">response<\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"> =&gt;<\/span><\/span><\/span> {\r\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Berhasil: \'<\/span><\/span><\/span>, response);\r\n})\r\n.catch(<span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err<\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"> =&gt;<\/span><\/span><\/span> {\r\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Gagal: \'<\/span><\/span><\/span>, err);\r\n});<\/code><\/pre> <p>\r\n          Sangat sederhana bukan? Sangat berbeda jika kita menulis menggunakan <code>XMLHttpRequest<\/code>.\r\n        <\/p> <p>\r\n          Akan tetapi, fetch API ini memiliki perbedaan ketika menangani error. Jika error ketika request dihasilkan karena kesalahan menulis API endpoint, maka <code>.then()<\/code> tetap akan dieksekusi. Hanya saja akan ada perbedaan pada status code nya.\r\n        <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/09-1.webp\" alt=\"Hasil request menggunakan fetch\"> <figcaption>Hasil request menggunakan fetch<\/figcaption><\/figure> <p>\r\n          Terlihat bahwa tertulis \u201Cberhasil\u201D, tetapi status yang dibalikkan adalah 404. Itu menandakan bahwa API endpoint tersebut tidak ada pada server.\r\n        <\/p> <p>\r\n          Lalu bagaimana jika API endpoint kita benar? Apa yang akan dibalikkan oleh response?\r\n        <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/09-2.webp\" alt=\"Hasil request menggunakan fetch\"> <figcaption>Hasil request menggunakan fetch<\/figcaption><\/figure> <p>\r\n          Status code dari response akan bernilai 200. Tetapi kita tidak melihat data response yang dikembalikan dari request. Bagaimana cara mengambil data responsenya?\r\n        <\/p> <p>\r\n          Jika kita lihat dalaman dari <code>__proto__: Response<\/code>, maka akan terlihat method <code>json<\/code>. Method <code>json<\/code> inilah yang kita gunakan untuk mengambil data response.\r\n        <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/09-3.webp\" alt=\"Isi dari __proto__: Response\"> <figcaption>Isi dari __proto__: Response<\/figcaption><\/figure> <p>\r\n          Sebelum kita mengambil data dari method <code>json<\/code>, yang perlu kita ketahui terlebih dahulu adalah bahwa method <code>json<\/code> memiliki balikan berupa promise. Sehingga untuk mengambil data response, kita tidak bisa langsung menaruhnya di variabel. Lalu untuk mengambil data responsenya, kita akan lakukan seperti ini.\r\n        <\/p> <pre><code class=\"javascript hljs\">fetch(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span><\/span><\/span>)\r\n.then(<span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">response<\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"> =&gt;<\/span><\/span><\/span> {\r\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Berhasil: \'<\/span><\/span><\/span>, response);\r\n  <span class=\"hljs-keyword\"><span class=\"hljs-keyword\"><span class=\"hljs-keyword\">return<\/span><\/span><\/span> response.json();\r\n})\r\n.then(<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\">(<\/span><\/span><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\">) =&gt;<\/span><\/span><\/span> {\r\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span>.log(data);\r\n})\r\n.catch(<span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\"><span class=\"hljs-function\"><span class=\"hljs-params\">err<\/span><\/span><\/span><\/span><\/span><span class=\"hljs-function\"><span class=\"hljs-function\"> =&gt;<\/span><\/span><\/span> {\r\n  <span class=\"hljs-built_in\"><span class=\"hljs-built_in\"><span class=\"hljs-built_in\">console<\/span><\/span><\/span>.log(<span class=\"hljs-string\"><span class=\"hljs-string\"><span class=\"hljs-string\">\'Gagal: \'<\/span><\/span><\/span>, err);\r\n});<\/code><\/pre> <p>\r\n          Berikut adalah hasil yang ada di console.\r\n        <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/09-4.webp\" alt=\"Data response dari fetch\"> <figcaption>Data response dari fetch<\/figcaption><\/figure> <p>\r\n          Beberapa hal yang perlu diperhatikan ketika menggunakan fetch API adalah:\r\n        <\/p> <ul><li>Fungsi <code>fetch<\/code> selalu mengembalikan promise.<\/li> <li>Response yang dikembalikan dari <code>fetch<\/code> tidak langsung mengembalikan response data. Kita perlu menjalankan method <code>json()<\/code> untuk mengambil data tersebut.<\/li> <li>Method <code>json()<\/code> juga mengembalikan nilai promise. Sehingga kita perlu menulis blok <code>then()<\/code> lagi untuk mendapatkan response data.<\/li><\/ul>`,
  },
  {
    slug: 'async-dan-await',
    label: 'Async & Await',
    image_thumbnail: '10.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Apa itu async dan await?<\/h1> <p>\r\n            Salah satu yang menarik dari javascript asynchronous yang perlu kita bahas adalah <code>async<\/code> dan <code>await<\/code>. Keyword <code>async<\/code> dan <code>await<\/code> terhitung baru diperkenalkan dan termasuk bahasa javascript yang cukup modern. Inti dari kedua keyword tersebut adalah kita bisa melakukan pengikatan promise dengan penulisan kode yang jauh lebih rapi dan bersih.\r\n          <\/p> <p>\r\n            Mari kita pratinjau kode yang sebelumnya kita tulis.\r\n          <\/p> <pre><code class=\"javascript hljs\">fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\'<\/span>)\r\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Berhasil: \'<\/span>, response);\r\n    <span class=\"hljs-keyword\">return<\/span> response.json();\r\n  })\r\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">data<\/span>) =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  })\r\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-string\">\'Gagal: \'<\/span>, err);\r\n  });<\/code><\/pre> <p>\r\n            Dari kode di atas dapat dibaca bahwa kita banyak memanggil fungsi <code>.then()<\/code> untuk mengeksekusi sebuah proses asynchronous. Cara seperti itu masih cukup oke dan terlihat lebih rapi jika dibandingkan dengan callback hell sebelumnya. Akan tetapi bayangkan jika kita memiliki banyak sekali HTTP request. Lama kelamaan kode seperti itu akan terlihat sedikit berantakan.\r\n          <\/p> <p>\r\n            Menggunakan keyword <code>async<\/code> dan <code>await<\/code> dapat memecahkan masalah tersebut. Kita dapat membuat sebuah fungsi dengan keyword <code>async<\/code> yang menandakan bahwa fungsi ini akan berjalan secara asynchronous. Lalu ketika kita memanggil fungsi tersebut, kita bisa menggunakan keyword <code>await<\/code> yang menandakan bahwa fungsi ini perlu ditunggu hingga prosesnya selesai.\r\n          <\/p> <h1>HTTP request menggunakan async dan await<\/h1> <p>\r\n            Untuk permulaan, kita akan menulis kode seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> response = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\/\'<\/span>);\r\n\r\n  <span class=\"hljs-built_in\">console<\/span>.log(response);\r\n};\r\n\r\ngetTodo();\r\n<\/code><\/pre> <p>\r\n            Satu hal yang perlu dipahami bahwa fungsi yang memiliki keyword <code>async<\/code> di depan, maka fungsi tersebut akan otomatis memiliki balikan promise. Sehingga kita dapat meminimalkan penulisan kode kita.\r\n          <\/p> <p>\r\n            Kita ingat bahwa <code>fetch<\/code> membutuhkan method <code>json()<\/code> untuk menampilkan data. Maka kita akan menambah satu baris lagi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> response = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-keyword\">await<\/span> response.json();\r\n\r\n  <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n};\r\n\r\ngetTodo();\r\n<\/code><\/pre> <p>\r\n            Console browser akan menjadi seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/10-1.webp\" alt=\"Hasil request menggunakan asyn dan await\"> <figcaption>Hasil request menggunakan asyn dan await<\/figcaption><\/figure> <p>\r\n            Atau bisa juga kita menjadikan data tersebut sebagai balikan dari fungsi <code>getTodo<\/code>.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> response = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-keyword\">await<\/span> response.json();\r\n\r\n  <span class=\"hljs-keyword\">return<\/span> data;\r\n};\r\n\r\ngetTodo().then(<span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span> =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});\r\n<\/code><\/pre> <h1>Chaining promise menggunakan async &amp; await<\/h1> <p>\r\n            Kita juga bisa melakukan pengikatan promise menggunakan <code>async<\/code> dan <code>await<\/code>. Penulisan kode akan menjadi seperti ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> responseOne = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> dataOne = <span class=\"hljs-keyword\">await<\/span> responseOne.json();\r\n  <span class=\"hljs-keyword\">const<\/span> responseTwo = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/users\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> dataTwo = <span class=\"hljs-keyword\">await<\/span> responseTwo.json();\r\n  <span class=\"hljs-keyword\">const<\/span> responseThree = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/posts\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> dataThree = <span class=\"hljs-keyword\">await<\/span> responseThree.json();\r\n\r\n  <span class=\"hljs-keyword\">return<\/span> {\r\n    dataOne, dataTwo, dataThree\r\n  };\r\n};\r\n\r\ngetTodo().then(<span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span> =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});<\/code><\/pre> <p>\r\n            Hasil pada console akan menjadi seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/10-2.webp\" alt=\"Hasil request menggunakan asyn dan await dengan chaining promise\"> <figcaption>Hasil request menggunakan asyn dan await dengan chaining promise<\/figcaption><\/figure> <p>\r\n            Dengan menggunakan keyword <code>await<\/code> di dalam fungsi <code>async<\/code>, itu menandakan bahwa pernyataan tersebut perlu ditunggu hingga selesai. Meskipun begitu, proses menunggunya tidak mengakibatkan blocker ke proses utamanya.\r\n          <\/p> <p>\r\n            Untuk membuktikan hal tersebut, mari kita gunakan kode yang sudah sering kita pakai.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> responseOne = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> dataOne = <span class=\"hljs-keyword\">await<\/span> responseOne.json();\r\n  <span class=\"hljs-keyword\">const<\/span> responseTwo = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/users\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> dataTwo = <span class=\"hljs-keyword\">await<\/span> responseTwo.json();\r\n  <span class=\"hljs-keyword\">const<\/span> responseThree = <span class=\"hljs-keyword\">await<\/span> fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/posts\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> dataThree = <span class=\"hljs-keyword\">await<\/span> responseThree.json();\r\n\r\n  <span class=\"hljs-keyword\">return<\/span> {\r\n    dataOne, dataTwo, dataThree\r\n  };\r\n};\r\n\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">1<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">2<\/span>);\r\n\r\ngetTodo().then(<span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span> =&gt;<\/span> {\r\n  <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n});\r\n\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">3<\/span>);\r\n<span class=\"hljs-built_in\">console<\/span>.log(<span class=\"hljs-number\">4<\/span>);\r\n<\/code><\/pre> <p>\r\n            Berikut adalah hasil pada console browser.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/10-3.webp\" alt=\"Hasil request menggunakan asyn dan await tidak menimbulkan blocking\"> <figcaption>Hasil request menggunakan asyn dan await tidak menimbulkan blocking<\/figcaption><\/figure> <p>\r\n            Terlihat dari console bahwa kode async tidak menghalangi proses utama dari program.\r\n          <\/p> <p>\r\n            Jika kita ingin menggunakan keyword <code>async<\/code> dan <code>await<\/code>, perlu diperhatikan bahwa kedua keyword ini tidak mendukung browser yang sudah lama seperti Internet Explorer.\r\n          <\/p>`,
  },
  {
    slug: 'throwing-error',
    label: 'Throwing Error',
    image_thumbnail: '11.webp',
    isUnlock: true,
    isActive: false,
    content: `<h1>Membuat custom error<\/h1> <p>\r\n            Kita juga bisa membuat error kita sendiri ketika terjadi kegagalan proses asynchronous.\r\n          <\/p> <p>\r\n            Untuk melakukan ini, kita bisa menggunakan kode yang sebelumnya sudah kita tulis.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> response = fetch(<span class=\"hljs-string\">\'https:\/\/jsonplaceholder.typicode.com\/todos\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-keyword\">await<\/span> response;\r\n\r\n  <span class=\"hljs-keyword\">return<\/span> data;\r\n};\r\n\r\ngetTodo()\r\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  })\r\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(err.message);\r\n  });<\/code><\/pre> <p>\r\n            Kita perlu melakukan sesuatu supaya request kita error. Kita dapat mengubah API endpoint nya menjadi string asal supaya HTTP request kita error.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> response = fetch(<span class=\"hljs-string\">\'https:\/\/inistringasal.com\/\'<\/span>);\r\n  <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-keyword\">await<\/span> response;\r\n\r\n  <span class=\"hljs-keyword\">return<\/span> data;\r\n};\r\n\r\ngetTodo()\r\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  })\r\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(err.message);\r\n  });\r\n<\/code><\/pre> <p>\r\n            Pesan error pada console akan seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/11-1.webp\" alt=\"Pesan error ketika gagal request\"> <figcaption>Pesan error ketika gagal request<\/figcaption><\/figure> <p>\r\n            Kita akan mengubah pesan error yang muncul pada console browser tersebut.\r\n          <\/p> <p>\r\n            Sebelumnya kita sudah memahami bahwa request yang berhasil akan memiliki status code 200. Maka jika ada request dengan status code bukan 200, berarti request tersebut error. Dari logika seperti itu, kita bisa membuat kode seperti di bawah ini.\r\n          <\/p> <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">const<\/span> getTodo = <span class=\"hljs-keyword\">async<\/span> () =&gt; {\r\n\r\n  <span class=\"hljs-keyword\">const<\/span> response = fetch(<span class=\"hljs-string\">\'https:\/\/inistringasal.com\/\'<\/span>);\r\n\r\n  <span class=\"hljs-keyword\">if<\/span> (response.status !== <span class=\"hljs-number\">200<\/span>) {\r\n    <span class=\"hljs-keyword\">throw<\/span> <span class=\"hljs-keyword\">new<\/span> <span class=\"hljs-built_in\">Error<\/span>(<span class=\"hljs-string\">\'Ada error nih gan!\'<\/span>);\r\n  }\r\n  <span class=\"hljs-keyword\">const<\/span> data = <span class=\"hljs-keyword\">await<\/span> response;\r\n\r\n  <span class=\"hljs-keyword\">return<\/span> data;\r\n};\r\n\r\ngetTodo()\r\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(data);\r\n  })\r\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err<\/span> =&gt;<\/span> {\r\n    <span class=\"hljs-built_in\">console<\/span>.log(err.message);\r\n  });<\/code><\/pre> <p>Maka pada console akan menjadi seperti ini.\r\n          <\/p> <figure><img src=\"\/images\/yuk_belajar\/async_js\/11-2.webp\" alt=\"Pesan error yang kita buat sendiri\"> <figcaption>Pesan error yang kita buat sendiri<\/figcaption><\/figure> <p>\r\n            Jika kita perhatikan, perintah <code>throw new Error()<\/code> digunakan untuk melempar sebuah error ke pengguna. Kita bisa membuat pesan error sendiri melalui itu.\r\n          <\/p>`,
  }
];
